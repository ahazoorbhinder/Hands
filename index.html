<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Ahmad Hazoor Bhinder(AHB)</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  background: black;
  overflow: hidden;
}
canvas {
  position: fixed;
  inset: 0;
}
video {
  position: fixed;
  right: 10px;
  bottom: 10px;
  width: 160px;
  opacity: 1;
  z-index: 10;
}
</style>
</head>

<body>

<video id="video" autoplay playsinline muted></video>
<canvas id="three"></canvas>

<!-- THREE -->
<script src="https://cdn.jsdelivr.net/npm/three@0.158/build/three.min.js"></script>

<!-- MEDIAPIPE -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* =====================================================
   VIDEO INITIALIZATION
===================================================== */
const video = document.getElementById("video");
navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } })
  .then(stream => {
    video.srcObject = stream;
    video.onloadedmetadata = () => video.play();
  })
  .catch(err => { alert("Camera access failed"); console.error(err) });

/* =====================================================
   THREE.JS
===================================================== */
const canvas = document.getElementById("three");
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.z = 4;

const renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);

/* =====================================================
   PARTICLES
===================================================== */
const COUNT = 5000;
const geometry = new THREE.BufferGeometry();

function makeHeart() {
  const arr = new Float32Array(COUNT*3);
  for(let i=0;i<COUNT;i++){
    const t=Math.random()*Math.PI*2;
    arr[i*3] = Math.sin(t)**3*1.5;
    arr[i*3+1] = (Math.cos(t)*1.3 - Math.cos(2*t))*1.5;
    arr[i*3+2] = (Math.random()-0.5)*0.5;
  }
  return arr;
}

function makeFlower() {
  const arr = new Float32Array(COUNT*3);
  for(let i=0;i<COUNT;i++){
    const a=Math.random()*Math.PI*2;
    const r = Math.sin(5*a)+1.5;
    arr[i*3] = Math.cos(a)*r*0.5;
    arr[i*3+1] = Math.sin(a)*r*0.5;
    arr[i*3+2] = (Math.random()-0.5)*0.5;
  }
  return arr;
}

function makeSaturn() {
  const arr = new Float32Array(COUNT*3);
  for(let i=0;i<COUNT;i++){
    const a=Math.random()*Math.PI*2;
    const r=1+Math.sin(a*3)*0.3;
    arr[i*3]=Math.cos(a)*r*0.6;
    arr[i*3+1]=(Math.random()-0.5)*0.2;
    arr[i*3+2]=(Math.random()-0.5)*0.5;
  }
  return arr;
}

function makeFireworks() {
  const arr = new Float32Array(COUNT*3);
  for(let i=0;i<COUNT;i++){
    const u=Math.random(), v=Math.random();
    const th = 2*Math.PI*u, ph = Math.acos(2*v-1);
    arr[i*3]=Math.sin(ph)*Math.cos(th)*1.2;
    arr[i*3+1]=Math.sin(ph)*Math.sin(th)*1.2;
    arr[i*3+2]=Math.cos(ph)*1.2;
  }
  return arr;
}

/* Initialize */
geometry.setAttribute("position", new THREE.BufferAttribute(makeHeart(), 3));

const material = new THREE.PointsMaterial({
  size: 0.03,
  color: 0xff66cc
});

const particles = new THREE.Points(geometry, material);
scene.add(particles);

/* =====================================================
   HANDS
===================================================== */
const hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.6,
  minTrackingConfidence: 0.6
});

const shapeList = ["heart","flower","saturn","fireworks"];
let currentShapeIndex = 0;
let pinchLocked = false;
let scaleTarget = 1;
let zoomTarget = 4;
const PINCH_THRESHOLD = 0.05;

/* Relative rotation variables */
let lastHandPos = null; // previous hand position
let rotationVelocity = new THREE.Vector2(0,0);

/* =====================================================
   HANDS CALLBACK
===================================================== */
hands.onResults(results => {
  if(!results.multiHandLandmarks || results.multiHandLandmarks.length===0) {
    lastHandPos = null;
    return;
  }

  const hand = results.multiHandLandmarks[0];
  const thumb = hand[4];
  const index = hand[8];
  const pinch = Math.hypot(thumb.x - index.x, thumb.y - index.y);

  /* COLOR */
  material.color.setHSL(Math.min(pinch*4,1), 1, 0.6);

  /* SCALE */
  scaleTarget = pinch < PINCH_THRESHOLD ? 0.6 : 1.4;

  /* RELATIVE ROTATION */
  const wrist = hand[0];
  if(lastHandPos){
    // difference from last frame → rotation velocity
    const dx = wrist.x - lastHandPos.x;
    const dy = wrist.y - lastHandPos.y;

    rotationVelocity.y += dx * Math.PI; // left/right → Y rotation
    rotationVelocity.x += dy * Math.PI; // up/down → X rotation
  }
  lastHandPos = {x: wrist.x, y: wrist.y};

  /* ZOOM (hand size proxy) */
  const palm = hand[0];
  const middle = hand[9];
  const handSize = Math.hypot(palm.x - middle.x, palm.y - middle.y);
  zoomTarget = THREE.MathUtils.clamp(6 - handSize * 10, 2, 8);

  /* DEBOUNCED SHAPE SWITCH */
  if (pinch < PINCH_THRESHOLD && !pinchLocked) {
    pinchLocked = true;
    currentShapeIndex = (currentShapeIndex + 1) % shapeList.length;

    let newPositions;
    switch (shapeList[currentShapeIndex]) {
      case "heart": newPositions = makeHeart(); break;
      case "flower": newPositions = makeFlower(); break;
      case "saturn": newPositions = makeSaturn(); break;
      case "fireworks": newPositions = makeFireworks(); break;
    }

    geometry.setAttribute("position", new THREE.BufferAttribute(newPositions, 3));
  }

  if (pinch > PINCH_THRESHOLD * 1.5) pinchLocked = false;
});

/* =====================================================
   MEDIAPIPE CAMERA
===================================================== */
const mpCamera = new Camera(video, {
  onFrame: async()=>{ if(video.readyState===4) await hands.send({image:video}) },
  width:640, height:480
});
mpCamera.start();

/* =====================================================
   ANIMATION LOOP
===================================================== */
function animate() {
  requestAnimationFrame(animate);

  // Apply rotation velocity with smoothing
  particles.rotation.x += rotationVelocity.x;
  particles.rotation.y += rotationVelocity.y;

  // decay velocity for inertia effect
  rotationVelocity.multiplyScalar(0.9);

  // Smooth scaling
  particles.scale.lerp(
    new THREE.Vector3(scaleTarget, scaleTarget, scaleTarget),
    0.15
  );

  // Smooth zoom
  camera.position.z += (zoomTarget - camera.position.z) * 0.1;

  renderer.render(scene, camera);
}
animate();

/* =====================================================
   RESIZE
===================================================== */
window.addEventListener("resize", ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
